 \documentclass{beamer}
\setbeamercovered{transparent}
\usepackage{epstopdf}
\usepackage{listings}
\usepackage{lipsum}
\usepackage{subfig}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{cite}
\usepackage{lipsum}
\usepackage{amssymb}
\usepackage{color}
\usepackage{IEEEtrantools}
\usepackage{booktabs}
\usepackage{texpower}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{multirow}
\usepackage{graphicx}
\newtheorem{Key points}{Key points}
\newtheorem{Summary}{Summary}
\usepackage{dblfloatfix}
%\usepackage{adjustbox}
%\usepackage{animate}
%\usepackage{movie15}
%\usepackage{subfig}
%\newtheorem{Definition}{Definition}
%\usepackage[font={small}]{caption}
\usepackage{beamerthemeshadow}
\newcommand\Fontvi{\fontsize{5}{6.2}\selectfont}
\newcommand\Fontvia{\fontsize{6}{7.2}\selectfont}
\newcommand\Fontviaa{\fontsize{8}{7.2}\selectfont}
\usepackage{listings}
\lstset{language=C++,
                keywordstyle=\color{blue},
                stringstyle=\color{red},
                commentstyle=\color{red},
                morecomment=[l][\color{magenta}]{\#},
                numbers=left,
                escapeinside=||
}

%\captionsetup{font=scriptsize,labelfont=scriptsize}
 \usetheme{Antibes}%PaloAlto
\begin{document}
\title[Lecture 9]{Data Structures and Object Oriented Programming using C++} 
\author[]{Ahsan Ijaz}
\date{}
 \frame{\titlepage}
% \AtBeginSection[]
% {
% \begin{frame}<beamer>{Table of Contents}
% \tableofcontents[currentsection,currentsubsection, 
%     hideothersubsections, 
%     sectionstyle=show/shaded,
% ]
% \end{frame}
% }

\section{Templates}
\frame{\frametitle{Templates}
  \begin{itemize}
  \item  Function templates are special functions that can operate with generic types. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.
  \end{itemize}
 }

\begin{frame}[fragile]
\frametitle{Function Overloading using cout}
\begin{lstlisting}
void PrintTwice(int data)
{
    cout << "Twice is: " << data * 2 << endl;         
}

void PrintTwice(double data)
{
    cout << "Twice is: " << data * 2 << endl;         
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Function Overloading using printf}
\begin{lstlisting}
void PrintTwice(int data)
{
    printf("Twice is: %d", data * 2 );
}

void PrintTwice(double data)
{
    printf("Twice is: %lf", data * 2 );
}
\end{lstlisting}
\end{frame}
\frame{\frametitle{Templates}
\vspace{\fill}
  \begin{itemize}
  \item  Class type \textbf{ostream} (the type of cout object) has multiple overloads for operator \textbf{$<<$} for all basic data-types. Therefore, same/similar code works for both int and double, and no change is required for our \textbf{PrintTwice}.
  \end{itemize}
\vspace{\fill}
 }
\frame{\frametitle{Types of Templates}
  \begin{itemize}
  \item Function Templates
  \item Class Templates
  \end{itemize}
Without template, you would need to replicate same code all over again and again, for all required data-types. 
}

\begin{frame}[fragile]
\frametitle{Function Template Example}
\begin{lstlisting}
template<class TYPE>
void PrintTwice(TYPE data)
{
    cout<<"Twice: " << data * 2 << endl;
}
\end{lstlisting}

{\color{red}\textbf{template$<$class TYPE$>$}}

tells the compiler that this is a function-template. The actual meaning of TYPE would be deduced by compiler depending on the argument passed to this function. Here, the name, TYPE is known as template type parameter.
\end{frame}

\frame{\frametitle{Compiler Instantiate Appropriate Function}
   \begin{itemize}
  \item On calling \textbf{PrintTwice(124)}:
    \begin{itemize}
    \item TYPE would be replaced by compiler as int.
    \end{itemize}
  \item If call is made to \textbf{PrintTwice(4.5547)}:
    \begin{itemize}
    \item TYPE would be replaced by compiler as double automatically.
    \end{itemize}
  \end{itemize}
Without template, you would need to replicate same code all over again and again, for all required data-types. 
}

\begin{frame}[fragile]
\frametitle{Compiler does the overloading}
It means, in your program, if you call PrintTwice function with int and double parameter types, two instances of this function would be generated by compiler:

\begin{lstlisting}
void PrintTwice(int data) { ... }

void PrintTwice(double data) { ... }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Return type Example}

\begin{lstlisting}
template<typename TYPE>
TYPE Twice(TYPE data)
{
   return data * 2;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Return type Example}
When we call:
\begin{lstlisting}
cout << Twice(10);
cout << Twice(3.14);
\end{lstlisting}

Following set of functions would be generated:

\begin{lstlisting}
int     Twice(int data) {..}
double  Twice(double data) {..}
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Addition Example}
When we call:
\begin{lstlisting}
template<class T>
T Add(T n1, T n2)
{
    T result;
    result = n1 + n2;
    
    return result;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Multiple Types with Function Templates}
When we call:
\begin{lstlisting}
template<class T1, class T2>
void PrintNumbers(const T1& t1Data, const T2& t2Data)
{
     cout << "First value:" << t1Data;
     cout << "Second value:" << t2Data;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile,fragile]
\frametitle{Multiple Types with Function Templates}
On calling these functions:
\begin{lstlisting}
PrintNumbers(10, 100);    // int, int
PrintNumbers(14, 14.5);   // int, double
PrintNumbers(59.66, 150); // double, int
\end{lstlisting}
Compiler translates:
\begin{lstlisting}
// const and reference removed for simplicity
void PrintNumbers(int t1Data, int t2Data);
void PrintNumbers(int t1Data, double t2Data);
void PrintNumbers(double t1Data, int t2Data);
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Explicit type specification in Templates}
\begin{lstlisting}
PrintNumbers<double, double>(10, 100);    // int, int
PrintNumbers<double, double>(14, 14.5);   // int, double
PrintNumbers<double, double>(59.66, 150); // double, int
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Class Templates}
A class template is used to define an abstract type whose behavior is generic and is reusable, adaptable.
\end{frame}

\begin{frame}[fragile]
\frametitle{Simple Class Example}
A simple example of a Class:
\Fontviaa
\begin{lstlisting}
class Item
{
    int Data;
public:
    Item() : Data(0)
    {}

    void SetData(int nValue)
    { 
        Data = nValue;
    }

    int GetData() const
    {
        return Data;
    }

    void PrintData()
    {
        cout << Data;
    }
};
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{What if you need flexibility in class definition??}
Simple enough, right?? But, when you need similar abstraction for other data-type, you need to duplicate code of entire class (or at least the required methods). It incurs code maintenance issues, increases code size at source code as well as at binary level.
\end{frame}
\begin{frame}[fragile]
\frametitle{Class Templates to the rescue}
\Fontviaa
\begin{lstlisting}
template<class T>
class Item
{
    T Data;
public:
    Item() : Data( T() ) //int Data = int();
    {}

    void SetData(T nValue)
    {
        Data = nValue;
    }

    T GetData() const
    {
        return Data;
    }

    void PrintData()
    {
        cout << Data;
    }
};
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Usage of Class}
\begin{lstlisting}
Item<int> item1;
item1.SetData(120);
item1.PrintData();
\end{lstlisting}
Or you can cause the compiler to generate a float type data member like this: 
\begin{lstlisting}
Item<float> item2;
float n = item2.GetData();
\end{lstlisting}
\end{frame}
\end{document}